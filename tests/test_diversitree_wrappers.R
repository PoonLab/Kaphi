# This file is part of Kaphi.

# Kaphi is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Kaphi is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Kaphi.  If not, see <http://www.gnu.org/licenses/>.

require(Kaphi, quietly=TRUE)
require(RUnit, quietly=TRUE)
require(igraph)

## TODO: Call to igraph C library function (igraph_shortest_paths)
##       instead of adding igraph R package as a dependency.

test.yule.model <- function() {
  ## Simulate tree under Yule model (n=1000):
  config <- load.config('tests/fixtures/test-yule.yaml')
  config <- set.model(config, 'yule')
  theta <- sample.priors(config)
  tree <- speciation.model(theta, nsim=1, tips=1000, 'yule')[[1]]
  
  ## Use igraph function to generate matrix of pathlengths between nodes:
  igtree <- as.igraph(tree)
  paths <- shortest.paths(igtree)
  
  ## Must remove paths involving internal nodes:
  leaf.path <- paths[c(!grepl('nd', colnames(paths))), 
                     c(!grepl('nd', rownames(paths)))]

  ## Probability Distribution for probability of each path:
  pd <- as.data.frame(table(leaf.path))
  pd <- pd[!(grepl('^0$', pd$leaf.path, perl=TRUE)), ]
  length <- length(pd$Freq)
  total <- sum(pd$Freq)
  
  ## Add column of probabilities:
  prob <- c()
  for (i in seq(1:length)) {
    prob <- c(prob, as.numeric(pd$Freq[i]) / total)
  }
  pd$prob <- prob
  
  ## Add column of weighted path lengths:
  w.mean <- c()
  for (i in seq(1:length)) {
    w.mean <- c(w.mean, as.numeric(pd$leaf.path[i]) * as.numeric(pd$prob[i]))
  }
  pd$w.mean <- w.mean
  
  ## Calculate expected distance
  exp <- sum(w.mean) 
  
  ## Analytical solution for expected distance between 2 leaves: 
  ## Solution from equation (6) in: Steel, M., & McKenzie, A. (2001). Properties 
  ## of phylogenetic trees generated by Yule-type speciation models. Mathematical 
  ## biosciences, 170(1), 91-112.
  sol <- 21.9678512934948628
  
  ## Compare analytical value to the value from the simluated tree:
  res <- abs(sol-exp)
  epsilon <- 2.00
  checkTrue(res < epsilon)
}


test.speciation.model <- function() {
    ## Test BiSSE:
    ## Set config (unif priors), simulate tree sets, calculate self-kernels
    trees1 <- trees(c(0.1, 0.2, 0.003, 0.003, 0.01, 0.01), 
                    type='bisse', n=20, max.taxa=20)  
    config <- load.config('tests/fixtures/test-bisse.yaml')
    config <- set.model(config, 'bisse')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'bisse') 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    
    ## Set names (to improve readability for testing)
    #names1 <- c('t1.1', 't1.2', 't1.3') 
    #names(trees1) <- names1 
    #names2 <- c('t2.1', 't2.2', 't2.3')
    #names(trees2) <- names2
    
    ## Kernel distances between pairs within trees1
    #nms <- combn(names(trees1), 2, FUN = paste0, collapse = "", simplify = FALSE)
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    #setNames(out,nms)
    
    ## Kernel distance between pairs between trees1 and trees2
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    
    ## Compare distributions
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
    
    
    ## Test BiSSE-ness:
    trees1 <- trees(c(0.1, 0.2, 0.003, 0.003, 0.01, 0.01, 0.05, 0.1, 0.05, 0.1), 
                    type='bisseness', n=20, max.taxa=20)  
    config <- load.config('tests/fixtures/test-bisseness.yaml')
    config <- set.model(config, 'bisseness')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'bisseness') 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
   
    
    ## Test Birth-Death:
    trees1 <- trees(c(0.1, 0.003), type='bd', n=20, max.taxa=20)  
    config <- load.config('tests/fixtures/test-bd.yaml')
    config <- set.model(config, 'bd')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'bd') 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
    
    
    ## Test ClaSSE:
    trees1 <- trees(c(2.5, 0.5, 0, 0, 0, 5, 2.41, 5.24, 0.5, 0), type='classe',
                    n=20, max.taxa=20)
    config <- load.config('tests/fixtures/test-classe.yaml')
    config <- set.model(config, 'classe')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'classe') 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
    
    
    ## Test GeoSSE:
    trees1 <- trees(c(1.5, 0.5, 1.0, 0.7, 0.7, 1.5, 1.5), type='geosse', n=20, 
                    max.taxa=20)
    config <- load.config('tests/fixtures/test-geosse.yaml')
    config <- set.model(config, 'geosse')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'geosse') 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
    
    
    ## Test MuSSE:
    trees1 <- trees(c(0.1, 0.07, 0.2, 0.03, 0.01, 0.06, 0.01, 0.03, 0.04, 
                    0.08, 0.1, 0.01), type='musse', n=20, max.taxa=20, x0=2)
    config <- load.config('tests/fixtures/test-musse.yaml')
    config <- set.model(config, 'musse')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'musse', x0=2) 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
    
    
    ## Test QuaSSE:
    ## TODO: Complete YAML file for QuaSSE (figure out priors for drift/diffusion)
    

    ## Test Yule:
    trees1 <- trees(c(0.1), type='yule', n=20, max.taxa=20)  
    config <- load.config('tests/fixtures/test-yule.yaml')
    config <- set.model(config, 'yule')
    theta <- sample.priors(config)
    trees2 <- speciation.model(theta, nsim=20, tips=20, 'yule') 
    trees1 <- lapply(trees1, function(st) parse.input.tree(st, config))
    trees2 <- lapply(trees2, function(st) parse.input.tree(st, config))
    pairs <- combn(trees1, 2, simplify=FALSE)
    out1 <- lapply(pairs, function(x) distance(x[[1]], x[[2]], config))
    m1 <- mean(unlist(out1))
    out2 <- lapply(trees1, function(t1) {
      lapply(trees2, function(t2) distance(t1, t2, config))
    })
    m2 <- mean(unlist(out2))
    epsilon <- 0.05
    res <- abs(m1-m2)
    checkTrue(res < epsilon)
    
    
    # Test Multiple Simulations:
    config <- load.config('tests/fixtures/test-bisse.yaml')
    config <- set.model(config, 'bisse')
    theta <- sample.priors(config)
    trees <- speciation.model(theta, nsim=50, tips=20, 'bisse')
    result <- length(trees) # 50 trees
    expected <- 50
    checkEquals(expected, result)
    

    ## Test varying tip numbers:
    tree <- speciation.model(theta, nsim=1, tips=5, 'bisse')[[1]]
    result <- length(tree$tip.label) # 5 tips
    expected <- 5
    checkEquals(expected, result)

    tree <- speciation.model(theta, nsim=1, tips=100, 'bisse')[[1]]
    result <- length(tree$tip.label) # 100 tips
    expected <- 100
    checkEquals(expected, result)
}
